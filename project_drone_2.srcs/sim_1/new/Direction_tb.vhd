------------------------------------------------------------------
-- Direction_tb
--
-- This testbench instantiates:
--  - The real PWM IP to generate 50 Hz PWM signals with 95%, 50% and 15% duty cycles
--  - The Direction IP (FSM version)
--
-- The objective is to verify that:
--   * motorLeft and motorRight correctly follow refPwmStd when both sensors are 0
--   * motorLeft follows refPwmSlw and motorRight follows refPwmFst when sensorLeft=1
--   * motorLeft follows refPwmFst and motorRight follows refPwmSlw when sensorRight=1
--   * both motors follow refPwmSlw when both sensors are 1 (lost case)
--   * both motors are forced to 0 when state_move = 0
--
-- Since Direction is implemented as a FSM, outputs are updated on rising edges of the clock. 
-- A latency of one clock cycle may therefore be observed.
------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Direction_tb is
end Direction_tb;

architecture sim of Direction_tb is

    -- Clock and reset
    signal clk   : std_logic := '0';
    signal reset : std_logic := '1';

    -- Sensor inputs and global move state
    signal sensorL    : std_logic := '0';
    signal sensorR    : std_logic := '0';
    signal state_move : std_logic := '0';

    -- PWM reference signals generated by the real PWM IP
    signal refPwmFst : std_logic;
    signal refPwmStd : std_logic;
    signal refPwmSlw : std_logic;

    -- Outputs of the Direction IP
    signal motorL : std_logic;
    signal motorR : std_logic;
    signal mode_left_tb  : std_logic_vector(1 downto 0);
    signal mode_right_tb : std_logic_vector(1 downto 0);

    -- 50 MHz clock period
    constant clk_period : time := 20 ns;

begin

    -- Clock generation
    clk_proc : process
    begin
        while now < 200 ms loop
            clk <= '0';
            wait for clk_period/2;
            clk <= '1';
            wait for clk_period/2;
        end loop;
        wait;
    end process;

    -- PWM IP instantiation (reference duty cycles: 95%, 50%, 15%)
    PWM_UUT : entity work.PWM
        port map(
            clk     => clk,
            reset   => reset,
            pwm_fst => refPwmFst,
            pwm_std => refPwmStd,
            pwm_slw => refPwmSlw
        );

    -- Direction IP instantiation (FSM)
    DIR_UUT : entity work.Direction
        port map(
            clk        => clk,
            reset      => reset,
            refPwmFst   => refPwmFst,
            refPwmStd   => refPwmStd,
            refPwmSlw   => refPwmSlw,
            sensorLeft  => sensorL,
            sensorRight => sensorR,
            state_move  => state_move,
            motorLeft   => motorL,
            motorRight  => motorR,
            mode_left   => mode_left_tb,
            mode_right  => mode_right_tb
        );

    -- Stimulus process
    stim_proc : process
    begin
        -- Reset phase
        reset <= '1';
        wait for 200 ns;
        reset <= '0';

        -- Motors stopped
        state_move <= '0';
        sensorL <= '0';
        sensorR <= '0';
        wait for 20 ms;

        -- Straight motion: standard speed on both motors
        state_move <= '1';
        sensorL <= '0';
        sensorR <= '0';
        wait for 20 ms;

        -- Left turn: left slow, right fast
        sensorL <= '1';
        sensorR <= '0';
        wait for 20 ms;

        -- Right turn: left fast, right slow
        sensorL <= '0';
        sensorR <= '1';
        wait for 20 ms;

        -- Lost case: both slow
        sensorL <= '1';
        sensorR <= '1';
        wait for 20 ms;

        -- Stop again
        state_move <= '0';
        wait for 25 ms;

        wait;
    end process;

end sim;
